#!/usr/bin/env python3
"""
CVE Security Monitoring Agent for Linux Services
Monitors and reports on recent CVE releases affecting Linux services
"""

import argparse
import json
import os
import sys
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional
import urllib.request
import urllib.parse
import urllib.error

# Configuration
CONFIG_DIR = Path.home() / '.config' / 'cve-monitor'
CACHE_DIR = CONFIG_DIR / 'cache'
CONFIG_FILE = CONFIG_DIR / 'config.json'
CACHE_FILE = CACHE_DIR / 'cve_cache.json'

# NVD API endpoint (v2.0)
NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

# Common Linux services and keywords to monitor
DEFAULT_LINUX_KEYWORDS = [
    'linux', 'kernel', 'systemd', 'apache', 'nginx', 'openssh', 'ssh',
    'postgresql', 'mysql', 'mariadb', 'redis', 'mongodb', 'docker',
    'kubernetes', 'containerd', 'bind', 'postfix', 'dovecot', 'samba',
    'nfs', 'cups', 'sudo', 'polkit', 'dbus', 'avahi', 'bluez',
    'openssl', 'gnutls', 'krb5', 'pam', 'glibc', 'bash', 'coreutils',
    'systemctl', 'journald', 'udev', 'NetworkManager', 'firewalld',
    'iptables', 'selinux', 'apparmor', 'rsyslog', 'logrotate',
    'cron', 'anacron', 'at', 'lvm', 'mdadm', 'xfs', 'ext4', 'btrfs',
    'gnome', 'kde', 'xorg', 'wayland', 'pulseaudio', 'pipewire',
    'vim', 'emacs', 'git', 'subversion', 'mercurial'
]

DEFAULT_CONFIG = {
    'api_key': None,  # Optional NVD API key for higher rate limits
    'days_back': 7,
    'severity_filter': ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'],
    'linux_keywords': DEFAULT_LINUX_KEYWORDS,
    'notify_command': None,  # Optional: command to run for notifications (e.g., 'notify-send')
    'max_results': 2000,  # Fetch up to 2000 CVEs (NVD API maximum)
    'cache_duration_hours': 6
}


class CVEMonitor:
    """Main CVE monitoring class"""

    def __init__(self, config_path: Optional[Path] = None):
        self.config_path = config_path or CONFIG_FILE
        self.config = self._load_config()
        self.cache = self._load_cache()

    def _load_config(self) -> Dict:
        """Load configuration from file or create default"""
        if self.config_path.exists():
            with open(self.config_path, 'r') as f:
                config = json.load(f)
                # Merge with defaults for any missing keys
                return {**DEFAULT_CONFIG, **config}
        else:
            CONFIG_DIR.mkdir(parents=True, exist_ok=True)
            CACHE_DIR.mkdir(parents=True, exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(DEFAULT_CONFIG, f, indent=2)
            return DEFAULT_CONFIG.copy()

    def _save_config(self):
        """Save current configuration to file"""
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)

    def _load_cache(self) -> Dict:
        """Load cached CVE data"""
        if CACHE_FILE.exists():
            try:
                with open(CACHE_FILE, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                return {'cves': {}, 'last_update': None}
        return {'cves': {}, 'last_update': None}

    def _save_cache(self):
        """Save CVE cache to file"""
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        with open(CACHE_FILE, 'w') as f:
            json.dump(self.cache, f, indent=2)

    def _make_nvd_request(self, params: Dict) -> Dict:
        """Make request to NVD API with rate limiting"""
        query_string = urllib.parse.urlencode(params)
        url = f"{NVD_API_URL}?{query_string}"

        headers = {}
        if self.config.get('api_key'):
            headers['apiKey'] = self.config['api_key']

        req = urllib.request.Request(url, headers=headers)

        try:
            with urllib.request.urlopen(req, timeout=30) as response:
                data = json.loads(response.read().decode())
                # Rate limiting: 5 requests per 30 seconds without API key
                # 50 requests per 30 seconds with API key
                if not self.config.get('api_key'):
                    time.sleep(6)  # Conservative rate limiting
                else:
                    time.sleep(0.6)
                return data
        except urllib.error.HTTPError as e:
            print(f"HTTP Error {e.code}: {e.reason}", file=sys.stderr)
            return {}
        except urllib.error.URLError as e:
            print(f"URL Error: {e.reason}", file=sys.stderr)
            return {}
        except Exception as e:
            print(f"Error making NVD request: {e}", file=sys.stderr)
            return {}

    def _is_linux_related(self, cve_data: Dict) -> bool:
        """Check if CVE is related to Linux services"""
        description = cve_data.get('cve', {}).get('descriptions', [{}])[0].get('value', '').lower()

        # Check configurations (CPE data)
        configurations = cve_data.get('cve', {}).get('configurations', [])
        for config in configurations:
            for node in config.get('nodes', []):
                for cpe_match in node.get('cpeMatch', []):
                    cpe = cpe_match.get('criteria', '').lower()
                    if any(keyword in cpe for keyword in self.config['linux_keywords']):
                        return True

        # Check description
        if any(keyword in description for keyword in self.config['linux_keywords']):
            return True

        return False

    def _get_severity(self, cve_data: Dict) -> str:
        """Extract CVSS severity rating"""
        metrics = cve_data.get('cve', {}).get('metrics', {})

        # Try CVSS v3.1
        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
            return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseSeverity', 'UNKNOWN')

        # Try CVSS v3.0
        if 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
            return metrics['cvssMetricV30'][0].get('cvssData', {}).get('baseSeverity', 'UNKNOWN')

        # Try CVSS v2
        if 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            score = metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore', 0)
            if score >= 7.0:
                return 'HIGH'
            elif score >= 4.0:
                return 'MEDIUM'
            else:
                return 'LOW'

        return 'UNKNOWN'

    def _get_cvss_score(self, cve_data: Dict) -> Optional[float]:
        """Extract CVSS base score"""
        metrics = cve_data.get('cve', {}).get('metrics', {})

        # Try CVSS v3.1
        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
            return metrics['cvssMetricV31'][0].get('cvssData', {}).get('baseScore')

        # Try CVSS v3.0
        if 'cvssMetricV30' in metrics and metrics['cvssMetricV30']:
            return metrics['cvssMetricV30'][0].get('cvssData', {}).get('baseScore')

        # Try CVSS v2
        if 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            return metrics['cvssMetricV2'][0].get('cvssData', {}).get('baseScore')

        return None

    def fetch_recent_cves(self, days_back: Optional[int] = None) -> List[Dict]:
        """Fetch recent CVEs from NVD"""
        if days_back is None:
            days_back = self.config['days_back']

        # Calculate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days_back)

        # Format dates for NVD API (ISO 8601)
        params = {
            'pubStartDate': start_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
            'pubEndDate': end_date.strftime('%Y-%m-%dT%H:%M:%S.000'),
            'resultsPerPage': min(self.config['max_results'], 2000)  # NVD max is 2000
        }

        # Note: We don't filter by severity at API level to ensure we don't miss CVEs
        # Severity filtering is done locally after fetching all results
        print(f"Fetching CVEs from {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}...")

        data = self._make_nvd_request(params)

        if not data or 'vulnerabilities' not in data:
            return []

        return data['vulnerabilities']

    def filter_and_process_cves(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Filter CVEs for Linux services and process them"""
        processed = []

        for vuln in vulnerabilities:
            cve_data = vuln
            cve_id = cve_data.get('cve', {}).get('id', 'UNKNOWN')

            # Check if Linux-related
            if not self._is_linux_related(cve_data):
                continue

            # Get severity
            severity = self._get_severity(cve_data)

            # Filter by severity
            if severity not in self.config['severity_filter']:
                continue

            # Extract relevant information
            description = cve_data.get('cve', {}).get('descriptions', [{}])[0].get('value', 'No description')
            published = cve_data.get('cve', {}).get('published', 'Unknown')
            cvss_score = self._get_cvss_score(cve_data)

            # Extract references
            references = []
            for ref in cve_data.get('cve', {}).get('references', []):
                references.append({
                    'url': ref.get('url', ''),
                    'source': ref.get('source', '')
                })

            processed.append({
                'cve_id': cve_id,
                'severity': severity,
                'cvss_score': cvss_score,
                'published': published,
                'description': description,
                'references': references
            })

        return processed

    def display_cves(self, cves: List[Dict], format_type: str = 'human'):
        """Display CVEs in specified format"""
        if not cves:
            print("No CVEs found matching criteria.")
            return

        if format_type == 'json':
            print(json.dumps(cves, indent=2))
            return

        # Human-readable format
        severity_colors = {
            'CRITICAL': '\033[1;31m',  # Bold Red
            'HIGH': '\033[0;31m',      # Red
            'MEDIUM': '\033[0;33m',    # Yellow
            'LOW': '\033[0;32m',       # Green
            'UNKNOWN': '\033[0;37m'    # White
        }
        reset_color = '\033[0m'

        print(f"\n{'='*80}")
        print(f"Linux CVE Security Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"{'='*80}\n")
        print(f"Total CVEs found: {len(cves)}\n")

        # Sort by severity and CVSS score
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'UNKNOWN': 4}
        cves_sorted = sorted(cves, key=lambda x: (
            severity_order.get(x['severity'], 5),
            -(x['cvss_score'] or 0)
        ))

        for cve in cves_sorted:
            color = severity_colors.get(cve['severity'], '')

            print(f"{color}[{cve['severity']}]{reset_color} {cve['cve_id']} - CVSS: {cve['cvss_score'] or 'N/A'}")
            print(f"  Published: {cve['published']}")
            print(f"  Description: {cve['description'][:200]}{'...' if len(cve['description']) > 200 else ''}")

            if cve['references']:
                print(f"  References:")
                for ref in cve['references'][:3]:  # Show first 3 references
                    print(f"    - {ref['url']}")

            print()

    def send_notification(self, cves: List[Dict]):
        """Send notification about new CVEs"""
        if not self.config.get('notify_command') or not cves:
            return

        critical_count = sum(1 for c in cves if c['severity'] == 'CRITICAL')
        high_count = sum(1 for c in cves if c['severity'] == 'HIGH')

        message = f"Found {len(cves)} new Linux CVEs: {critical_count} Critical, {high_count} High"

        try:
            import subprocess
            subprocess.run([self.config['notify_command'], 'CVE Alert', message])
        except Exception as e:
            print(f"Failed to send notification: {e}", file=sys.stderr)

    def monitor(self, days_back: Optional[int] = None, format_type: str = 'human',
                force_refresh: bool = False):
        """Main monitoring function"""
        # Check cache
        cache_valid = False
        if not force_refresh and self.cache.get('last_update'):
            last_update = datetime.fromisoformat(self.cache['last_update'])
            cache_age = datetime.now() - last_update
            if cache_age.total_seconds() < self.config['cache_duration_hours'] * 3600:
                cache_valid = True
                print(f"Using cached data from {last_update.strftime('%Y-%m-%d %H:%M:%S')}")

        if cache_valid and self.cache.get('cves'):
            cves = self.cache['cves']
        else:
            vulnerabilities = self.fetch_recent_cves(days_back)
            cves = self.filter_and_process_cves(vulnerabilities)

            # Update cache
            self.cache['cves'] = cves
            self.cache['last_update'] = datetime.now().isoformat()
            self._save_cache()

        # Apply severity filter to cached or fresh data
        filtered_cves = [cve for cve in cves if cve['severity'] in self.config['severity_filter']]

        self.display_cves(filtered_cves, format_type)
        self.send_notification(filtered_cves)

        return filtered_cves


def main():
    parser = argparse.ArgumentParser(
        description='CVE Security Monitoring Agent for Linux Services',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                          # Monitor last 7 days (default)
  %(prog)s --days 30                # Monitor last 30 days
  %(prog)s --severity CRITICAL HIGH # Only show critical and high severity
  %(prog)s --json                   # Output in JSON format
  %(prog)s --config-show            # Show current configuration
  %(prog)s --refresh                # Force refresh, ignore cache
        """
    )

    parser.add_argument('-d', '--days', type=int,
                       help='Number of days back to search (default: 7)')
    parser.add_argument('-s', '--severity', nargs='+',
                       choices=['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'],
                       help='Filter by severity levels')
    parser.add_argument('-j', '--json', action='store_true',
                       help='Output in JSON format')
    parser.add_argument('--refresh', action='store_true',
                       help='Force refresh, ignore cache')
    parser.add_argument('--config-show', action='store_true',
                       help='Show current configuration')
    parser.add_argument('--config-edit', action='store_true',
                       help='Open configuration file in editor')
    parser.add_argument('--api-key', type=str,
                       help='Set NVD API key for higher rate limits')

    args = parser.parse_args()

    monitor = CVEMonitor()

    # Handle configuration commands
    if args.config_show:
        print(json.dumps(monitor.config, indent=2))
        return

    if args.config_edit:
        editor = os.environ.get('EDITOR', 'vim')
        os.system(f"{editor} {CONFIG_FILE}")
        return

    if args.api_key:
        monitor.config['api_key'] = args.api_key
        monitor._save_config()
        print(f"API key saved to {CONFIG_FILE}")
        return

    # Update config with command line args
    if args.severity:
        monitor.config['severity_filter'] = args.severity

    # Run monitoring
    try:
        monitor.monitor(
            days_back=args.days,
            format_type='json' if args.json else 'human',
            force_refresh=args.refresh
        )
    except KeyboardInterrupt:
        print("\nMonitoring interrupted by user.", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
